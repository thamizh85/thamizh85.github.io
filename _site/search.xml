<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title><![CDATA[Emulating Angry IP Scanner with nmap scripting engine - A lua scripting primer]]></title>
      <url>/scripting/2017/10/29/emulating-angryip-scanner-with-nmap-scripting-engine-a-lua-scripting-primer/</url>
      <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Often we have to discover the devices on a network. I use a very simple nmap command for performing a pingsweep.</p>

<p><code class="highlighter-rouge">sudo nmap -sn &lt;subnet or ip range&gt;</code></p>

<p>On my work PC which runs Windows, I wrap it around in a batch script and place it in the search PATH. On Linux it can be dropped in as an alias in bashrc.</p>

<p>It is handy, but not complete. I would like to have some extra information such as hostnames (collected by various means not just DNS reverse lookup), platform info etc., Such details are available in tools such as AngryIP scanner, but I don’t prefer to launch a GUI tool for single task and keep it running until the task is done.</p>

<p>So I wanted to see if a similar function can be implemented using nmap script. There are existing scripts in nmap which performs advanced discovery and reconnaissance, but I wanted something lightweight, one which is least intrusive and outputs results in the format I desire. So I decided to try my hand in writing a script in NSE (Nmap Scripting Engine). The Nmap Scripting Engine, like Wireshark, uses Lua language. Learning it would expand the scope of these tools from just being a capable tool to a powerful tool with limitless possibilities.</p>

<p>The endeavour turned out to be fairly simple, but not without its share of frustrations, most of which were related to wrapping my head around the way NSE (Nmap Scripting Engine) tosses the data around and lua data structures. But once you get the hang of it, it is really simple. So without much ado, let us get started.</p>

<h2 id="nse-script-structure">NSE Script structure</h2>
<p>A basic NSE script will have the following 3 sections:</p>
<ul>
  <li>Head section is for meta information about the script. We need not worry about it for primer purpose but it is a good habit to put documentation info here while packaging script for production.</li>
  <li>Rule section determines the scope of the script. It basically acts as a filter of nmap port-scan results that gets filtered to the Action section. The rule section has to be one of the following:
    <ul>
      <li>prerule()</li>
      <li>hostrule(host)</li>
      <li>portrule(host, port)</li>
      <li>postrule()</li>
    </ul>
  </li>
  <li>Action section is mostly the brain of the script (although rule section can also contain some of the script logic). This section contains an Action section which reads data from the nmap scanning engine and carries out the script logic. The value returned by this function is also printed on the screen and captured by other nmap output methods. Note that this script is executed iteratively over either list of hosts or a list of (host, port) tuples.</li>
</ul>

<h2 id="diving-in">Diving In</h2>
<p>So let us go ahead and create a basic script. Our script will scan the target network and fetch the hostname from NETBIOS. Create a script file with .nse (I used host-discover.nse) extension as follows:</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="kd">local</span> <span class="n">netbios</span> <span class="o">=</span> <span class="nb">require</span> <span class="s2">"netbios"</span>
<span class="kd">local</span> <span class="n">shortport</span> <span class="o">=</span> <span class="nb">require</span> <span class="s2">"shortport"</span>

<span class="c1">-- The Rule Section --</span>
<span class="n">portrule</span> <span class="o">=</span> <span class="n">shortport</span><span class="p">.</span><span class="n">portnumber</span><span class="p">({</span><span class="mi">137</span><span class="p">},</span> <span class="s2">"udp"</span><span class="p">)</span>

<span class="c1">-- The Action Section --</span>
<span class="n">action</span> <span class="o">=</span> <span class="k">function</span><span class="p">(</span><span class="n">host</span><span class="p">,</span><span class="n">port</span><span class="p">)</span>
    <span class="kd">local</span> <span class="n">nbt_status</span><span class="p">,</span> <span class="n">netbios_name</span> <span class="o">=</span> <span class="n">netbios</span><span class="p">.</span><span class="n">get_server_name</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">netbios_name</span>
<span class="k">end</span>
</code></pre>
</div>
<p>Now run this script against your local network as below:</p>

<p><code class="highlighter-rouge">nmap --script host-discover.nse 10.1.1.0/24 -sU -p 137</code></p>

<p>Take a minute to gape at the results- you have your very own NETBIOS scanner, all in just 7 lines of functional code. There are standalone <a href="http://unixwiz.net/tools/nbtscan.html">tools</a> that exists just to perform this singular task and we did it using a generic swiss army knife tool such as nmap.</p>

<p>The magic that enables this are the excellent inbuilt scanning mechanisms of nmap and hot-pluggable libraries that carry out much of the grunt. By scripting in NSE, we can tap in to this massive capabilities of nmap and automate to our needs.</p>

<h2 id="code-walkthrough">Code Walkthrough</h2>
<p>For simplicity sake, I had skipped the HEAD section. Next thing you notice is the  Lua’s comment syntax. Comments starts with <code class="highlighter-rouge">--</code></p>

<p>Next we import the libraries necessary for our script. In Lua, modules are included using <code class="highlighter-rouge">require</code> function. And we assign the module to a local variable in order to access its namespace (i.e, call the methods that belong to the module).</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="kd">local</span> <span class="n">netbios</span> <span class="o">=</span> <span class="nb">require</span> <span class="s2">"netbios"</span>
<span class="kd">local</span> <span class="n">shortport</span> <span class="o">=</span> <span class="nb">require</span> <span class="s2">"shortport"</span>
</code></pre>
</div>
<p>The purpose of these libraries will be evident in the later section.</p>

<p>Next we move to the RULE section. Since our script is only interested with NETBIOS query, we have to pick only the hosts that are listening on port UDP/137.</p>

<p>But determining whether a host is listening on a port is not so trivial. We have to check it against few valid states (‘open’ or ‘filtered’). ‘shortport’ module abstracts this detail from us and allows us to simply filter port status. It is not necessary to use this  module if you can write your own conditions.</p>

<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="c1">-- The Rule Section --</span>
<span class="n">portrule</span> <span class="o">=</span> <span class="n">shortport</span><span class="p">.</span><span class="n">portnumber</span><span class="p">({</span><span class="mi">137</span><span class="p">},</span> <span class="s2">"udp"</span><span class="p">)</span>
</code></pre>
</div>
<p>NOTE: The Rule section only filters port numbers passed on from the upper layer i.e, the original nmap scan. It doesn’t trigger a port scan on its own. That is why when we launch the script, we had to specify port number explicitly (<code class="highlighter-rouge">nmap -sU U:137 &lt;host&gt;</code>). It is still possible to launch a port scan in this section, by calling nmap socket libraries but those are advanced scripting scenarios.</p>

<p>Next comes the ACTION section. Our action section here is a function that takes (host, port) as argument. It means the host object and port object are available to this function for evaluating logic. If we need other variables, they have to be declared outside this function.</p>

<p>Since for NETBIOS query we only need the host our action function will take only ‘host’ as argument. We call the get_server_name function of <a href="https://nmap.org/nsedoc/lib/netbios.html#get_server_name">netbios</a> module. From the documentation we can see that this function returns two values, query status and query result which we capture under two local variables. For our simple task, we need not check the result status and go ahead to return the name variable directly. In Lua, if a variable doesn’t exist it returns nil which is acceptable for our scenario.</p>
<div class="language-lua highlighter-rouge"><pre class="highlight"><code><span class="c1">-- The Action Section --</span>
<span class="n">action</span> <span class="o">=</span> <span class="k">function</span><span class="p">(</span><span class="n">host</span><span class="p">,</span><span class="n">port</span><span class="p">)</span>
    <span class="kd">local</span> <span class="n">nbt_status</span><span class="p">,</span> <span class="n">netbios_name</span> <span class="o">=</span> <span class="n">netbios</span><span class="p">.</span><span class="n">get_server_name</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">netbios_name</span>
<span class="k">end</span>
</code></pre>
</div>
<p>This returned value is processed by nmap scripting engine and printed in the output window.</p>

<h2 id="where-to-go-next">Where to go next</h2>
<p>Since this is only a basic script, we have not customized the output format at all. The hostnames when available gets printed below each host-discovered. If you notice, the print action is executed within the ACTION function whose scope is limited to one host at a time. If we need our output to be consolidated in a tabular form, we can write a postrule function, store and retrieve our findings from nmap registry. Refer to my <a href="https://raw.githubusercontent.com/thamizh85/Nmap-scripts/master/hostinfo-discover.nse">script</a> (work in progress) to see one way of doing it.</p>

<p>I strongly recommend trying the tutorial at this <a href="https://thesprawl.org/research/writing-nse-scripts-for-vulnerability-scanning/">site</a> for further study. It greatly helped me to get started with NMAP scripting and understanding the way a NSE script is structured.</p>

<p>It won’t hurt to improve your understanding of LUA programming language as well. I found this 15 minute <a href="http://tylerneylon.com/a/learn-lua/">primer</a> to be very useful.</p>

<p>Lastly the greatest resource for advanced nmap script writing is the existing script library. There are hundreds of scripts and libraries available, study and explore them to see different ways of tackling a challenge. Good luck scripting!</p>
]]></content>
      <categories>
        
          <category> Scripting </category>
        
      </categories>
      <tags>
        
          <tag> lua </tag>
        
          <tag> nmap </tag>
        
          <tag> network-discovery </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Using a bluetooth serial console with linux]]></title>
      <url>/notes/2017/08/24/using-a-bluetooth-serial-console-with-linux/</url>
      <content type="html"><![CDATA[<p>Recently I bought a <a href="https://www.aliexpress.com/store/product/FREE-SHIPPING-Bt578-rs232-wireless-male-female-general-serial-port-bluetooth-adapter-bluetooth-module/719457_1271204185.html">bluetooth RS232 serial convertor</a>. I wasn’t sure whether it would work with my Linux laptop. But it turned out to be quite simple to setup.</p>

<h2 id="pre-requisites">Pre-requisites</h2>

<p>The following packages are required:</p>
<ul>
  <li>bluez</li>
  <li>bluez-utils</li>
  <li>byobu (optional)</li>
</ul>

<p>Bluez provides the bluetooth protocol stack (most likely shipped with the OS), bluez-utils provides the bluetoothctl utility and byobu is a wrapper around screen terminal emulator. You can also use ‘screen’ directly. Install these using your distributions recommended procedure.</p>

<h2 id="steps">Steps</h2>

<ol>
  <li>Start daemon:
    <div class="language-shell highlighter-rouge"><pre class="highlight"><code> Swanky:~<span class="nv">$ </span>systemctl start bluetooth
</code></pre>
    </div>
  </li>
  <li>Discover using bluetoothctl:
    <div class="language-shell highlighter-rouge"><pre class="highlight"><code> Swanky:~<span class="nv">$ </span>bluetoothctl
 <span class="o">[</span>NEW] Controller &lt;controller-mac-address&gt; xkgt-Swanky <span class="o">[</span>default]
 <span class="o">[</span>bluetooth]# power on
 <span class="o">[</span>bluetooth]# scan on
</code></pre>
    </div>
  </li>
  <li>Once you can see your device, turn off the scan and pair
    <div class="language-shell highlighter-rouge"><pre class="highlight"><code> <span class="o">[</span>bluetooth]# scan off
 <span class="o">[</span>bluetooth]# pair &lt;device-mac-address&gt;
</code></pre>
    </div>
  </li>
  <li>Exit blutoothctl and create serial device (Note that root privileges are required):
    <div class="language-shell highlighter-rouge"><pre class="highlight"><code> <span class="o">[</span>bluetooth]# <span class="nb">exit
 </span>Swanky:~<span class="nv">$ </span>sudo rfcomm <span class="nb">bind </span>0 &lt;device-mac-address&gt;
</code></pre>
    </div>
  </li>
  <li>You should now have /dev/rfcomm0. Connect to it using byobu-screen utility:
    <div class="language-shell highlighter-rouge"><pre class="highlight"><code> Swanky:~<span class="nv">$ </span>byobu-screen /dev/rfcomm0
</code></pre>
    </div>
  </li>
</ol>

<p>Enjoy your wireless console connection!</p>
]]></content>
      <categories>
        
          <category> Notes </category>
        
      </categories>
      <tags>
        
          <tag> bluetooth </tag>
        
          <tag> Linux </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Self-signed certificate chain using OpenSSL X509 module]]></title>
      <url>/notes/sysadmin/2017/08/20/self-signed-certificate-chain-using-openssl-x509-module/</url>
      <content type="html"><![CDATA[<p>Generating a self-signed CA certificate or signing a web server certificate using openssl is very easy. But creating a certificate, which works without any warning on most modern browsers is a challenge. This challenge is compounded by ever-growing stringent requirements from the popular browsers (See footnote 1).</p>

<p>There are two ways to use openssl to mimic a CA. The first option is to use ‘openssl ca’ module, for which there are many guides in the internet. This module mimics a full-fledged CA and useful when you are setting up something for long term requiring features such as CRL and OCSP.</p>

<p>The other option is to use ‘openssl x509’ module which is what we will be focusing on. I chose this because I just needed a certificate pair for one-off use and didn’t want to be bothered in setting up an elaborate CA configuration. The guide will be useful for someone with a similar objective.</p>

<p>As always, let us start with the requirement:</p>
<ol>
  <li>Create a certificate chain with as little configuration and minimum number of hosts, which means no intermediate CA.</li>
  <li>The CA cert would be imported manually in to Trusted Root Authorities on the client machines.</li>
  <li>The certificate should work on modern browsers. We will use latest versions of Chrome and Mozilla as benchmarks.</li>
</ol>

<h2 id="steps">Steps:</h2>

<ol>
  <li>Generate private key &amp; self-signed cert for the CA in a single statement:</li>
</ol>

<div class="highlighter-rouge"><pre class="highlight"><code>root@EARWA:openssl req -new -x509 &lt;span style="color:blue;"&gt;-sha256&lt;/span&gt; -newkey rsa:2048 -nodes -keyout &lt;span style="color:#ff0000;"&gt;ca.key&lt;/span&gt; -days 1000 -out &lt;span style="color:#808000;"&gt;ca.pem&lt;/span&gt;
root@EARWA:~/ca2# ls -ltr
total 8
-rw-r--r-- 1 root root 1704 Jul 30 20:01 &lt;span style="color:#ff0000;"&gt;ca.key&lt;/span&gt;
-rw-r--r-- 1 root root 1261 Jul 30 20:01 &lt;span style="color:#808000;"&gt;ca.pem&lt;/span&gt;
</code></pre>
</div>

<blockquote>Note: Always use SHA256 as highlighted above. SHA-1 has been deprecated since Jan 2017 (See footnote 2)</blockquote>

<ol>
  <li>Preparing a config file for CSR: We need to generate a CSR (Certificate Signing Request). This process involves generating a private key and a PEM encoded CSR file. The contents of our Web cert are determined by the information we provide in the CSR.</li>
</ol>

<p>Modern browsers expect a field called sAN(subjectAltName) (See footnote 3). This field should hold all possible URI’s from which our webserver may get accessed.</p>

<p>Since OpenSSL’s default interactive process of CSR generation doesn’t support this field, we need to specify it in a config file and generate the CSR. based on this file Create a config file for Web server request. The highlighted sections are the reason we are using a config file. Otherwise rest of the attributes can be passed interactively.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>root@EARWA:~/ca2# more &lt;span style="color:#ff0000;"&gt;web.earwa.com.conf&lt;/span&gt;
[ subject ]
countryName             = Country Name (2 letter code)
countryName_default     = HK

organizationName            = Organization Name (eg, company)
organizationName_default    = Scarlet Spires

basicConstraints    = CA:FALSE
keyUsage            = digitalSignature, keyEncipherment
&lt;span style="color:#0000ff;"&gt;subjectAltName      = @alternate_names&lt;/span&gt;
nsComment           = "OpenSSL Generated Certificate"

&lt;span style="color:#0000ff;"&gt;[ alternate_names ]
DNS.1       = web.earwa.com
DNS.2       = www.web.earwa.com&lt;/span&gt;
</code></pre>
</div>

<ol>
  <li>Submit a request based on the config file</li>
</ol>

<div class="highlighter-rouge"><pre class="highlight"><code>openssl req -config &lt;span style="color:#ff0000;"&gt;web.earwa.com.conf&lt;/span&gt; -new -sha256 -newkey rsa:2048 -nodes -keyout web.earwa.com.key -days 1000 -out web.earwa.com.csr
</code></pre>
</div>

<ol>
  <li>Check the generated request file before signing. The highlighted section shows the portions we are interested to validate.</li>
</ol>

<div class="highlighter-rouge"><pre class="highlight"><code>root@EARWA:~/ca2# openssl req -in web.earwa.com.csr -text -noout

Certificate Request:
    Data:
        Version: 0 (0x0)
        Subject: C=HK, O=Scarlet Spires
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (2048 bit)
                Modulus:
                    00:c6:f9:32:79:11:20:ff:97:da:38:a0:61:b9:41:
                    1f:51:c0:1f:a1:48:05:74:54:81:23:9b:22:24:8d:
                    35:f2:25:83:15:f2:9b:30:a5:43:2d:4d:08:2f:c7:
                    9e:42:1d:f7:66:68:07:8f:da:0b:f9:5c:51:97:b1:
                    0e:dc:44:d1:a4:5c:a1:ef:35:43:84:52:99:34:9f:
                    7d:41:54:9f:65:21:4c:1c:21:6f:9c:73:d5:f2:3d:
                    3c:6d:da:fe:85:88:98:4d:02:42:52:ea:9c:61:fe:
                    e7:bc:c2:d6:44:9d:9f:f6:3d:cb:32:c6:e4:8d:d1:
                    74:47:80:87:ac:8d:8a:64:8a:4e:54:ce:54:4e:75:
                    3a:85:af:f5:96:9b:5f:a0:a0:6d:27:06:1c:8d:0b:
                    4b:c5:1e:15:ff:16:4a:87:1e:9b:cc:98:a9:c5:8f:
                    4f:f1:19:28:cd:90:6c:85:ab:58:37:14:d6:58:cb:
                    7d:ab:8b:34:62:2a:72:b4:17:96:0b:6f:84:31:54:
                    55:aa:06:56:00:04:5e:2d:d1:14:fa:7f:2d:b3:44:
                    d3:1d:95:c2:93:ec:4e:17:e8:30:fa:e7:f5:be:b1:
                    5f:9a:59:59:ac:0d:b7:04:4a:19:35:a2:a5:44:64:
                    d4:a0:93:f8:dc:9f:3a:20:7b:5c:d7:26:67:28:67:
                    87:73
                Exponent: 65537 (0x10001)
        Attributes:
&lt;span style="color:#0000ff;"&gt;        Requested Extensions:
            X509v3 Subject Key Identifier:
                30:47:85:A6:4E:9C:E0:D4:F7:CC:9F:FF:FF:38:03:FC:E7:0E:87:00
            X509v3 Basic Constraints:
                CA:FALSE
            X509v3 Key Usage:
                Digital Signature, Key Encipherment
            X509v3 Subject Alternative Name:
                DNS:web.earwa.com, DNS:www.web.earwa.com
            Netscape Comment:
                OpenSSL Generated Certificate&lt;/span&gt;

    Signature Algorithm: sha256WithRSAEncryption
         aa:be:6d:d1:95:8a:1e:87:d8:72:7a:95:2e:01:18:f5:76:6e:
         28:e9:f8:a7:f0:ff:f5:5c:b3:95:99:ad:84:fd:bb:c3:fe:71:
         cc:a5:52:26:ce:2e:d0:d8:78:11:b9:33:98:f9:7c:42:e8:29:
         7e:8e:86:6c:b4:84:93:04:65:8e:d1:05:fd:6e:c2:94:bd:b1:
         c9:06:59:b7:8e:de:f4:42:9a:af:f8:96:c2:e9:85:2d:74:f6:
         24:41:96:da:f9:79:a5:3b:c7:42:8b:49:39:b6:9f:2b:a3:de:
         b1:9c:b3:66:f4:5b:7f:e7:b7:f4:c9:cb:60:cc:38:01:59:d1:
         61:c3:05:51:2d:c1:f8:63:d5:c5:40:e6:4d:06:3b:1b:06:93:
         ca:80:23:13:0d:79:7a:b3:2a:a3:8d:0f:a7:94:38:35:09:e4:
         69:5a:93:d4:c3:c6:26:ce:71:1f:0b:f1:03:d2:ae:0a:9e:06:
         04:1c:7d:4e:fd:07:d7:e8:bf:45:a0:c9:48:bb:38:a6:fb:09:
         5f:f0:84:42:ee:d9:fe:71:2b:24:6c:04:49:cb:f5:eb:7a:81:
         67:56:e8:9a:6f:fc:45:da:0a:2c:31:42:72:43:01:d0:e7:b9:
         a7:25:77:9a:21:f5:70:33:b6:b0:e0:75:00:29:d5:ce:77:61:
         f5:ec:00:a0
</code></pre>
</div>

<ol>
  <li>This is the portion that tripped me up for a while. Note that earlier I said that the info provided in CSR will be used for certificate generation. It is only partially true, the x509 module cannot copy the extensions info directly from CSR. We need to manually add extensions by using the options -extensions and -extfile. So let us create the V3 extension file first.</li>
</ol>

<div class="highlighter-rouge"><pre class="highlight"><code>root@EARWA:~/ca2# more &lt;span style="color:#ff0000;"&gt;v3.ext&lt;/span&gt;
[ &lt;span style="color:#0000ff;"&gt;v3_req&lt;/span&gt; ]
authorityKeyIdentifier=keyid,issuer
basicConstraints=CA:FALSE
keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment
subjectAltName      = @alternate_names


[ alternate_names ]
DNS.1       = web.earwa.com
DNS.2       = www.web.earwa.com
</code></pre>
</div>

<ol>
  <li>Sign the cert. The highlighted portions refers back to the extension file and the section mentioned above.</li>
</ol>

<div class="highlighter-rouge"><pre class="highlight"><code>openssl x509 -extensions &lt;span style="color:#0000ff;"&gt;v3_req&lt;/span&gt; -extfile &lt;span style="color:#ff0000;"&gt;v3.ext&lt;/span&gt; -req -sha256 -days 1000 -in web.earwa.com.csr -CA ca.pem -CAcreateserial -CAkey ca.key -out web.earwa.com.pem
</code></pre>
</div>

<ol>
  <li>Verify the cert</li>
</ol>

<div class="highlighter-rouge"><pre class="highlight"><code>root@EARWA:~/ca2# openssl x509 -in web.earwa.com.pem -text -noout

Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number: 14178612693219512833 (0xc4c48d1f7b319201)
    Signature Algorithm: sha256WithRSAEncryption
        Issuer: C=HK, ST=Some-State, O=Scarlet Spires
        Validity
            Not Before: Jul 31 16:36:03 2017 GMT
            Not After : Apr 26 16:36:03 2020 GMT
        Subject: C=HK, O=Scarlet Spires
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (2048 bit)
               Modulus:
                    00:c6:f9:32:79:11:20:ff:97:da:38:a0:61:b9:41:
                    1f:51:c0:1f:a1:48:05:74:54:81:23:9b:22:24:8d:
                    35:f2:25:83:15:f2:9b:30:a5:43:2d:4d:08:2f:c7:
                    9e:42:1d:f7:66:68:07:8f:da:0b:f9:5c:51:97:b1:
                    0e:dc:44:d1:a4:5c:a1:ef:35:43:84:52:99:34:9f:
                    7d:41:54:9f:65:21:4c:1c:21:6f:9c:73:d5:f2:3d:
                    3c:6d:da:fe:85:88:98:4d:02:42:52:ea:9c:61:fe:
                    e7:bc:c2:d6:44:9d:9f:f6:3d:cb:32:c6:e4:8d:d1:
                    74:47:80:87:ac:8d:8a:64:8a:4e:54:ce:54:4e:75:
                    3a:85:af:f5:96:9b:5f:a0:a0:6d:27:06:1c:8d:0b:
                    4b:c5:1e:15:ff:16:4a:87:1e:9b:cc:98:a9:c5:8f:
                    4f:f1:19:28:cd:90:6c:85:ab:58:37:14:d6:58:cb:
                    7d:ab:8b:34:62:2a:72:b4:17:96:0b:6f:84:31:54:
                    55:aa:06:56:00:04:5e:2d:d1:14:fa:7f:2d:b3:44:
                    d3:1d:95:c2:93:ec:4e:17:e8:30:fa:e7:f5:be:b1:
                    5f:9a:59:59:ac:0d:b7:04:4a:19:35:a2:a5:44:64:
                    d4:a0:93:f8:dc:9f:3a:20:7b:5c:d7:26:67:28:67:
                    87:73
                Exponent: 65537 (0x10001)
        &lt;span style="color:#0000ff;"&gt;X509v3 extensions:&lt;/span&gt;
            X509v3 Authority Key Identifier:
                keyid:32:33:41:52:11:5A:AE:F9:89:4E:8E:EE:26:E3:D2:7D:CA:C9:BC:63

            X509v3 Basic Constraints:
                CA:FALSE
            X509v3 Key Usage:
               Digital Signature, Non Repudiation, Key Encipherment, Data Encipherment
            X509v3 &lt;span style="color:#0000ff;"&gt;Subject Alternative Name:
                DNS:web.earwa.com, DNS:www.web.earwa.com&lt;/span&gt;
    Signature Algorithm: &lt;span style="color:#0000ff;"&gt;sha256WithRSAEncryption&lt;/span&gt;
         59:d5:45:b3:ca:60:32:a8:37:85:3b:bf:6f:d1:b3:26:f6:4b:
         f2:26:2c:68:6f:cb:5c:3b:a8:6f:a9:32:53:71:98:74:26:be:
         4f:3e:a9:13:e6:ba:e4:3e:52:83:86:0d:9d:53:4a:1e:e8:a5:
         94:36:bf:c2:17:62:b9:8e:87:8d:32:f1:34:1a:e3:81:6b:0b:
         5a:b7:a8:55:c4:24:ca:b2:65:75:e2:4b:ac:c4:9b:9e:d1:94:
         45:31:92:1d:6b:30:6c:29:03:fd:1e:49:8e:8e:d5:30:6f:68:
         fc:01:82:f8:57:83:85:47:15:e9:78:96:39:86:94:cb:96:29:
         5b:61:f0:d9:23:d1:25:ca:a0:ea:80:ce:42:bb:12:40:b9:64:
         c6:a5:4f:99:dc:f3:26:74:49:bc:b2:70:49:d2:22:f2:75:07:
         6e:8f:96:9b:e6:67:ad:21:01:23:57:46:ea:78:12:3b:c8:ba:
         dc:ae:39:ee:d6:30:6d:58:ab:f0:fe:c1:68:fb:0a:68:09:fc:
         93:28:84:27:2d:1d:c0:c2:06:53:1b:3b:ff:ec:d8:a1:90:1c:
         c4:59:c0:c3:d5:f4:bb:d4:79:35:dd:7f:05:60:3f:a9:ba:b0:
         5c:b3:66:13:03:4f:ac:31:0c:8a:e9:82:8d:36:c1:78:bf:d6:
         5e:6d:f9:13
</code></pre>
</div>

<p>That is it! Now you have a web server cert which would be trusted by most browsers, provided you import the root CA public cert in to the browsers’ trust chain.</p>

<h4 id="footnote-1">Footnote #1</h4>

<p><a href="https://cabforum.org/baseline-requirements-documents/">https://cabforum.org/baseline-requirements-documents/</a></p>

<h4 id="footnote-2">Footnote #2</h4>

<p>SHA-1 disabled on Chrome 56 and FireFox (Jan 2017)</p>

<p><a href="https://www.chromestatus.com/features/6601657605423104">https://www.chromestatus.com/features/6601657605423104</a></p>

<p><a href="https://sites.google.com/a/chromium.org/dev/Home/chromium-security/education/tls/sha-1">https://sites.google.com/a/chromium.org/dev/Home/chromium-security/education/tls/sha-1</a></p>

<p><a href="https://blog.mozilla.org/security/2017/02/23/the-end-of-sha-1-on-the-public-web/">https://blog.mozilla.org/security/2017/02/23/the-end-of-sha-1-on-the-public-web/</a></p>

<h4 id="footnote-3">Footnote #3</h4>

<p>SAN mandatory</p>

<p><a href="https://www.chromestatus.com/features/4981025180483584">https://www.chromestatus.com/features/4981025180483584</a></p>

<p><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1245280">https://bugzilla.mozilla.org/show_bug.cgi?id=1245280</a></p>

<p><a href="https://tools.ietf.org/html/rfc2818">https://tools.ietf.org/html/rfc2818</a></p>
]]></content>
      <categories>
        
          <category> Notes </category>
        
          <category> SysAdmin </category>
        
      </categories>
      <tags>
        
          <tag> openssl </tag>
        
          <tag> pki </tag>
        
          <tag> web </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Dynamic registration of DNS for Linux devices in an Active Directory environment with Windows DNS server]]></title>
      <url>/sysadmin/2017/07/19/dynamic-registration-of-dns-for-linux-devices-in-an-active-directory-environment-with-windows-dns-server/</url>
      <content type="html"><![CDATA[<p>While Linux has proliferated extensively in the server arena in the recent past, client networks are still dominated by Windows devices. This means, things that we take for granted in a client environment such as DDNS are not as matured as they are in Windows environment. One may ask whether the recent surge in Linux based clients such as IoT devices has changed this equation. But the nature of these devices is different from Windows based clients that they mostly rely on outbound connection to internet. Since they seldom require other hosts to initiate connection to them, their operation doesn’t rely much on Dynamic DNS.</p>

<p>So, what does it take to make a Linux client register dynamically in a Windows environment? At its basic, the entire process relies on Dynamic DNS as explained in <a href="https://tools.ietf.org/html/rfc2136">RFC2136</a>. In a traditional windows environment with AD, this process is taken care by client OS. Every time a Windows PC gets an IP address from DHCP server, it would send a DNS Update (Opcode = 5) request to its registered DNS server. Performed manually, this is same as typing “ipconfig /registerdns” at an elevated command prompt. This behaviour can be modified by accessing DNS section of Advanced TCP/IP settings of a network adapter.</p>

<p><img src="https://ephemeralelectrons.files.wordpress.com/2017/07/1-dns-properties.png" alt="1 - DNS Properties.png" /></p>

<p>When we ask a Linux client to do the same (later I will explain how it can be configured to ask), it won’t work unless the DNS server is configured to accept “Insecure updates” (Which is a major security risk if you need to ask).</p>

<p>Take a look at the capture of Linux client performing DNS update, you can see that the server comes back with a UPDATE REFUSED response.</p>

<p><img src="https://ephemeralelectrons.files.wordpress.com/2017/07/2-linux-dns-update-capture.png" alt="2 - Linux DNS Update Capture.png" /></p>

<p>This is because our DNS server is enabled with secure updates which means only authenticated clients can send update.</p>

<p><img src="https://ephemeralelectrons.files.wordpress.com/2017/07/3-dns-secure-updates-option.png" alt="3 - DNS Secure Updates option.png" /></p>

<p>The client is expected to send a transaction signature along with the update request. There are different types of signatures such as a TSIG resource or the SIG(0) or GSS-TSIG signatures. In Windows world however, only GSS-TSIG signatures as described in <a href="https://tools.ietf.org/html/rfc3645">RFC3645</a> are understood and accepted.</p>

<p>Looking at a capture from a Windows PC joined to domain, one can see the Windows Device sending Update request with GSS-TSIG resource.</p>

<p><img src="https://ephemeralelectrons.files.wordpress.com/2017/07/2-windows-dns-update-capture.png" alt="2 - Windows DNS Update Capture.png" /></p>

<p>Given this background, let us explore some of the options available to setup DDNS for Linux based clients. In this series of posts, I will explore 3 options:</p>
<ol>
  <li>Configure DHCP server to perform DNS registration on behalf of the clients</li>
  <li>Join the Linux devices to AD domain and configure them to dynamically update</li>
  <li>Setup a new sub-domain running a dedicated Linux BIND server and configure DNS forwarding on Microsoft DNS server.</li>
</ol>

<p>Our environment has the following setup:</p>
<ol>
  <li>Microsoft Active Directory environment with DNS server installed in Domain controller and a DHCP server running separately on a different host. All are running on Windows Server 2008 R2.</li>
  <li>DNS is configured to accept only Secure updates.</li>
  <li>Two Linux devices running Debian Stretch operating system. One of them will act as DNS server in one of the scenarios.</li>
</ol>

<p><img src="https://ephemeralelectrons.files.wordpress.com/2017/07/4-lab-topology.png" alt="4 - Lab Topology.png" /></p>

<p>The solutions we discuss should meet the following objectives:</p>
<ol>
  <li>Update DNS when the device gets an IP address</li>
  <li>Perform periodic update to DNS server to protect against expiry</li>
  <li>Fully automated with very little or no hand-coding on client devices, assume no automation tools like Puppet or Chef</li>
  <li>Scalable to hundreds or thousands of devices</li>
</ol>

<p>Point 3 is important to me since I had to work out a solution at work where we are using hundreds of Raspberry Pi’s, all booting the same image cloned on to flash disks. So, editing config files on each of them is not an option (we will come to this later).</p>

<hr />

<h2 id="configuring-dhcp-server-to-perform-dns-registration-on-behalf-of-the-clients">Configuring DHCP server to perform DNS registration on behalf of the clients</h2>

<p>This is the simplest and most reliable solution of the available options. This method makes use of DHCP option 81 as defined in <a href="https://tools.ietf.org/html/rfc4702">RFC4702</a>, which is used to convey a client’s FQDN to a DHCP server as part of DHCP process.</p>

<blockquote>An aside: RFC doesn’t mandate whether a DHCP server should register client’s DNS or not. It is left to site-specific policies, which may differ per the security context of the site.</blockquote>

<p>The default setting in a Microsoft DHCP server scope is as follows (Right click on scope name -&gt; Properties to reach here):</p>

<p><img src="https://ephemeralelectrons.files.wordpress.com/2017/07/5-default-scope-properties.png" alt="5 - Default scope properties.png" /></p>

<p>Understandably, this only updates to DNS server if requested by the client. What happens if we select the option to “Always dynamically update DNS A and PTR records”? Is that what we want?</p>

<p><img src="https://ephemeralelectrons.files.wordpress.com/2017/07/6-always-dynamically-update1.png" alt="6 - Always dynamically update.png" /></p>

<p>If you trigger a DHCP request from the client, you will notice that this doesn’t work.</p>

<p><img src="https://ephemeralelectrons.files.wordpress.com/2017/07/7-no-dns-update.png" alt="7 - No DNS Update.png" /></p>

<p>This setting merely controls whether a DHCP server should update ‘A’ record or not.  The label “Always dynamically update DNS A and PTR records” is misleading since it applies only for the clients that request a DNS update. By default, a client is responsible for updating the A record and DHCP server is responsible for updating the PTR record. Selecting the second option forces DHCP server to update A record as well. But the prerequisite is that the client should request for DNS update.</p>

<p><img src="https://ephemeralelectrons.files.wordpress.com/2017/07/8-dns-update-options.png" alt="8 - DNS Update options.png" /></p>

<p>The two options above correspond to the two cases discussed in <a href="https://tools.ietf.org/html/rfc4702">RFC4702</a></p>

<p><img src="https://ephemeralelectrons.files.wordpress.com/2017/07/9-rfc-4702.png" alt="9 - RFC 4702.png" /></p>

<p>For our Linux clients, the option we need is the last check box. Let us turn this on and trigger a DHCP request from our client.</p>

<p><img src="https://ephemeralelectrons.files.wordpress.com/2017/07/10-dynamically-update-for-linux-clients.png" alt="10 - Dynamically update for Linux clients.png" /></p>

<p>When we check the DNS server, we can see that the A record successfully is created.</p>

<p><img src="https://ephemeralelectrons.files.wordpress.com/2017/07/11-successful-registration.png" alt="11 - Successful Registration.png" /></p>

<p>On the capture, we can see secure DNS update message being sent from the DHCP server (Note that the DNS clients always tries insecure updates first and gets rejected by the server).</p>

<p><img src="https://ephemeralelectrons.files.wordpress.com/2017/07/12-successful-registration-packets.png" alt="12 - Successful Registration Packets.png" /></p>

<p>For a home environment, this is almost enough. But for production environments, with multiple DHCP servers, this is not enough. The problem is that, in such setup the DHCP server becomes the owner of the A and PTR records (see below). It is fine as long as the DHCP server is alive to create and remove records. But when it goes down, its peer DHCP server won’t be able to do anything about those records.</p>

<p><img src="https://ephemeralelectrons.files.wordpress.com/2017/07/13-a-record-owner.png" alt="13 - A record owner.png" /></p>

<p>This <a href="https://technet.microsoft.com/en-us/library/dd334715(v=ws.10).aspx">link</a> explains the issue in more detail. Let us follow the advice, create a dedicated user account for updating DNS and delete the old record with DHCP server as owner. Do not grant any extra privilege to this account. Just adding to DNSUpdateProxy group should be sufficient (Right click on IPv4 -&gt; Properties -&gt; Advanced).</p>

<p><img src="https://ephemeralelectrons.files.wordpress.com/2017/07/14-dynamic-update-credentials.png" alt="14 - Dynamic update credentials.png" /></p>

<p>As usual, let us go ahead to trigger an update.</p>

<p><img src="/images/2017-07-19-dynamic-registration-of-dns-for-linux-devices-in-an-active-directory-environment-with-windows-dns-server/15-dhcp-request.png" alt="15 - DHCP Request.png" /></p>

<p>As expected, new A and PTR record gets created.</p>

<p><img src="https://ephemeralelectrons.files.wordpress.com/2017/07/16-successful-registration.png" alt="16 - Successful Registration.png" /></p>

<p>If we check the ownership, we can find that the record is owned by DNSProxyUpdate group.</p>

<p><img src="https://ephemeralelectrons.files.wordpress.com/2017/07/16-dynamic-update-credentials1.png" alt="16 - Dynamic update credentials.png" /></p>

<hr />

<p>Finally, let us discuss the option called “Name Protection” at the bottom of the dialog box.</p>

<p><img src="https://ephemeralelectrons.files.wordpress.com/2017/07/17-name-protection.png" alt="17 - Name Protection.png" /></p>

<p>This forces DHCP server to manage the entire lifecycle of your client’s A and PTR records. If you are going to let your DHCP server manage client’s A record, I don’t see any reason to keep this disabled. It will also protect you from “<a href="https://technet.microsoft.com/en-us/library/dd759188(v=ws.11).aspx">Name Squatting</a>” by offline clients. <a href="https://tools.ietf.org/html/rfc4701">RFC4701 </a>describes the problem as:</p>

<p><img src="https://ephemeralelectrons.files.wordpress.com/2017/07/18-rfc4701.png" alt="18 - RFC4701.png" /></p>

<p>Let us see what it means to turn on this option. First, we keep it disabled and bring two clients online with same hostname, one after other. All is well when the first client comes online and gets an IP address 192.168.179.50.</p>

<p><img src="https://ephemeralelectrons.files.wordpress.com/2017/07/19-dhcp-request.png" alt="19 - DHCP Request.png" /></p>

<p>DNS also gets updated accordingly.</p>

<p><img src="https://ephemeralelectrons.files.wordpress.com/2017/07/20-dns-update.png" alt="20 - DNS Update.png" /></p>

<p>Let us bring another Linux client online and change the hostname to same as this host. Then perform a DHCP request from this host.</p>

<p><img src="https://ephemeralelectrons.files.wordpress.com/2017/07/21-hostname-change.png" alt="21 - Hostname change.png" /></p>

<p><img src="https://ephemeralelectrons.files.wordpress.com/2017/07/22-dhcp-request.png" alt="22 - DHCP Request.png" /></p>

<p>DHCP server assigns IP address 192.168.179.51 and sends an update to DNS server. Note that the DHCP server makes no fuss about two hosts sharing the same hostname. For all it knows, it could be the same host with multiple interfaces.</p>

<p><img src="https://ephemeralelectrons.files.wordpress.com/2017/07/23-dhcp-update.png" alt="23 - DHCP Update.png" /></p>

<p>On the DNS sever side, we see that it accepts this update without any hesitation. The only problem is that this overwrites the existing record, while the client is still online. So, anyone trying to talk the first node ends up talking to the second node.</p>

<p><img src="https://ephemeralelectrons.files.wordpress.com/2017/07/24-dns-overwritten.png" alt="24 - DNS overwritten.png" /></p>

<p>Clearly, DHCP server is not a reliable source of identity. RFC4703 briefly mentions the inability of DHCP server to provide any sort of assurance.</p>

<p><img src="https://ephemeralelectrons.files.wordpress.com/2017/07/25-rfc4703.png" alt="25 - RFC4703.png" /></p>

<p>Let us see what happens when we enable “Name Protection”.</p>

<p><img src="https://ephemeralelectrons.files.wordpress.com/2017/07/26-enable-name-protection.png" alt="26 - Enable Name Protection.png" /></p>

<p>As soon as we enable this option, first thing we notice is that all other options are greyed out. This is because, with Name Protection enabled, it is always the responsibility of DHCP server to perform both A record and PTR record updates.</p>

<p>Let us wipe the slate clean, by releasing IP address from both the clients and deleting the existing DNS &amp; DHCP records.</p>

<p>Now when you bring the first Linux client online, you can see that the DHCP server performs a new type of record registration called DHCID.</p>

<p><img src="https://ephemeralelectrons.files.wordpress.com/2017/07/27-successful-dhcid-capture.png" alt="27 - Successful DHCID Capture.png" /></p>

<p>A new record type DHCID appears in the DNS server.</p>

<p><img src="https://ephemeralelectrons.files.wordpress.com/2017/07/28-successful-dhcid-registered.png" alt="28 - Successful DHCID registered.png" /></p>

<p>Let us bring up the impostor and request DHCP address. It gets an IP address of 192.168.179.51.</p>

<p><img src="https://ephemeralelectrons.files.wordpress.com/2017/07/29-dns-impersonation.png" alt="29 - DNS Impersonation.png" /></p>

<p>As usual, DHCP server is very generous about having two hosts sharing the same hostname.</p>

<p><img src="https://ephemeralelectrons.files.wordpress.com/2017/07/30-duplicate-dhcp-update.png" alt="30 - Duplicate DHCP Update.png" /></p>

<p>But no new DNS entry is created.</p>

<p><img src="https://ephemeralelectrons.files.wordpress.com/2017/07/31-name-protection-success.png" alt="31 - Name protection success.png" /></p>

<p>Looking at the capture, we can see that the DNS registration fails with a response that RRset does not exist.</p>

<p><img src="https://ephemeralelectrons.files.wordpress.com/2017/07/32-dns-update-refused-capture.png" alt="32 - DNS Update refused capture.png" /></p>

<p>This message means that DHCID value calculated from the new update packet doesn’t match with any DHCID RR’s stored in the server. This behaviour is described in <a href="https://tools.ietf.org/html/rfc4701">RFC4701</a>.</p>

<p><img src="https://ephemeralelectrons.files.wordpress.com/2017/07/33-rfc4701.png" alt="33 - RFC4701.png" /></p>

<p>This is as much as we need to know about configuring a Microsoft DHCP server to perform Dynamic DNS for Linux clients. In the upcoming posts, let us explore the other two options.</p>
]]></content>
      <categories>
        
          <category> SysAdmin </category>
        
      </categories>
      <tags>
        
          <tag> DHCP </tag>
        
          <tag> DNS </tag>
        
          <tag> Dynamic DNS </tag>
        
          <tag> Linux </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
